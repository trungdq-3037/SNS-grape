exit
parsed_response[0]
parsed_response[1]
parsed_response
expect(parsed_response).to be_a(Array)
expect(parsed_response).to be(Array)
parsed_response
exit
@Post1
@post1
exit
post1
Post.first.id
Post.first
Post.all
exit
parsed_response.dig('user',"email")
parsed_response.dig('user',"name")
parsed_response('user',"name")
parsed_response.to_h.dig('user')
parsed_response.to_h.dig(:user)
parsed_response.to_h
parsed_response.dig(:user)
parsed_response.id
parsed_response.is_h?
parsed_response.is_hash?
parsed_response
parsed_response.dig(:user,:email)
expect(parsed_response['comments']).to be_a(Array)
expect(parsed_response['text']).to eq('Create a post')
expect(parsed_response['id']).to be_a(Integer)
expect(parsed_response.dig(:user,:email)).to eq('test@example.com')
expect(parsed_response.dig(:user,:email)).to eq('test@example.co
parsed_response
exit
parsed_response
expect(parsed_response['id']).to be_a(Integer)
exit
reload!
parsed_response
exit
 puts parsed_response['error']
        expect(parsed_response['error']).to eq('username is missing')
exit
áº½it
eixt
User.count
User.create(username: "test", email:"abc@gmail.com" , password:"abc")
User.count
exit
a["email"]
a.email
a
a[email]
a[:email]
a =JSON.parse response.body
JSON.parse response.body
response
response.body['email']
response.body[email]
response.body[:email]
response.body.email
response.body
response.body['email']
 expect(response.body['email']).to eq('trung1@example.com')
expect
json_response['email']
json_response
response.body
response
exit
User.count
User.first
User
User.all
User.find_by(email: "abc123123@gmail.com")
User.find_by email: "abc123123@gmail.com"
User.find_by email: "'abc123123@gmail.com"
response.body
response
exit
response
response.
response.json_response
response.methods
response.method?
response.methods?
response.message
response.status
response
exit
AuthenEntity
UserEntity
exit
@current_user
exit
@current_user = User.find(decoded[0]['id'])
 decoded = JWT.decode auth_token, SECRET_KEY
   @auth_token ||= request.headers.fetch('authorization', '').split(' ').last
request.headers.fetch('authorization', '')
request.headers
request.headers.fetch('Authorization', '')
auth_token
decoded = JWT.decode auth_token, SECRET_KEY
exit
next
status :unauthorized
